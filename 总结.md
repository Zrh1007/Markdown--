# 比赛情况
::cute-table{tuack}

|题目|分数|补题时间|
|:-----:|:--:|:---:|
|T714940 dfs-二维选和不选-1|100|0.66h|
|T715077 dfs-二维选和不选-2|80 |0.04h|
|T715078 dfs-二维选和不选-3|100|0.15h|
|T715079 dfs-二维选和不选-4|20 |0.49h|
|T715080 dfs-二维选和不选-5|0  |0.13h|
---
# DFS（二维）
::::info[DFS算法]{open}
- 深度优先搜索（Depth-First Search，DFS）是一种用于遍历或搜索树或图的算法。它从根节点开始，沿着每个分支尽可能深入地搜索，直到达到叶子节点或没有未访问的邻居节点为止，然后回溯到上一个节点继续搜索其他分支。
- DFS 通常使用递归或栈来实现。它适用于解决许多问题，如路径搜索、连通性检测、拓扑排序等。
- 在这里的 DFS 将用于选和不选，即从多个数中选出一个（或多个）满足条件的数。
::::
::::info[二维搜索]{open}
- 首先，我们来看一个例题：
:::info[例题]{open}
  给定一个二维数组 $a$，其中 $a_{i,j}<10^6$。求选取 $k$ 个元素的和的最大值。
:::
- 我们可以使用 DFS 来枚举所有可能的选择，即从 $a$ 中选出 $k$ 个元素的和的最大值。
- 具体的，我们可以从 $a$ 中选出 $k$ 个元素的和的最大值，即从 $a$ 中选出 $k$ 个元素的和的最大值。
- 实现：
:::success[DFS（二维搜索）]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int a[1005][1005];
int vis[1005][1005];
int ans=-1e9;
void dfs(int x,int y,int sum,int cnt){
    if(cnt==k){
        ans=max(ans,sum);
        return;
    }
    if(x<0||x>=n||y<0||y>=m||vis[x][y])return;
    vis[x][y]=1;
    dfs(x+1,y,sum+a[x][y],cnt+1);
    dfs(x-1,y,sum+a[x][y],cnt+1);
    dfs(x,y+1,sum+a[x][y],cnt+1);
    dfs(x,y-1,sum+a[x][y],cnt+1);
    vis[x][y]=0;
}
int main(){
    cin>>n>>m>>k;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>a[i][j];
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            dfs(i,j,0,0);
        }
    }
    cout<<ans;
    return 0;
}
```
:::
- 这就是二维 DFS 的基本思想。
- 时间复杂度：$O(nm^2)$，其中 $n$ 和 $m$ 分别是数组的行数和列数，$m^2$ 是 DFS 的栈深度。
::::

---

# 例题：

# T714940 dfs-二维选和不选-1

::::::info[题意简化]{open}
给定一个 $n$ 行 $n$ 列的棋盘，求在棋盘上 `#` 的位置摆放 $k$ 个棋子的所有可行的摆放方案数目。  
注意：棋子不能放在棋盘中的同一行或者同一列。
::::::

::::::info[题解]{open}
:::::info[DFS（二维搜索）]{open}
- 使用深度优先搜索（DFS）生成所有可能的选择，并计算每个选择的最大值，最终输出最大值。
::::success[DFS（二维搜索）]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,cnt;
char c[10][10];
int vis[10];
void dfs(int x,int y){
    if(y==k){
        cnt++;
        return;
    }
    if(x>n)return;
    for(int j=1;j<=n;j++){
        if(c[x][j]=='#'&& !vis[j]){
            vis[j]=1;
            dfs(x+1,y+1);
            vis[j]=0;
        }
    }
    dfs(x+1,y);
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    while(1){
        cnt=0;
        cin>>n>>k;
        if(n==-1&&k==-1)break;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                cin>>c[i][j];
            }
        }
        memset(vis,0,sizeof(vis));
        dfs(1,0);
        cout<<cnt<<'\n';
    }
    return 0;
}
```
::::
::::success[时间复杂度]{open}
- 时间复杂度：$O((n \times m)^2)$，其中 $n$ 是棋盘的大小。
::::
:::::
::::::
---

# T715077 dfs-二维选和不选-2

::::::info[题意简化]{open}
- 给定 $n$ 个点，每个点有一个圆心坐标 $(x_i, y_i)$ 和半径 $r_i$，你每次可以对一个半径为 $R$ 的圆的范围内进行消除，对于与你消除范围有交点的点都会消失，你总共可以发动 $k$ 次消除，问最多可以消除多少点？
::::::

::::::info[题解]{open}
:::::info[DFS（二维搜索）]{open}
 - 使用深度优先搜索（DFS）生成所有可能的选择，并计算每个选择的最大值，最终输出最大值。
 - 具体的，对于每个点 $i$，我们可以将其视为一个圆心坐标 $(x_i, y_i)$ 和半径 $r_i$，将其周围的点视为圆心坐标 $(x_j, y_j)$ 和半径 $R$，如果 $|x_i-x_j|+\|y_i-y_j\| \leq R+r_i$，则认为 $i$ 和 $j$ 有交点。
 - 我们可以枚举所有可能的圆心坐标 $(x_i, y_i)$ 和半径 $r_i$，然后统计消除范围内的点的个数，并记录最大值。
::::success[DFS（二维搜索）]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    long long x,y;
}f[200];
long long x[1500],y[1500],z[1500],idx,h[1500],res;
bool vis[3000];
long long n,k,r;
bool check(long long xi,long long yi,long long nx,long long ny,long long res){
    long long dx=xi-nx;
    long long dy=yi-ny;
    return dx*dx+dy*dy<=(res+r)*(res+r);
}
void dfs(long long step){
    if(step>k){
        long long cnt=0;
        for(long long i=1;i<=n;i++){
            for(long long j=1;j<=k;j++){
                long long nx=f[h[j]].x,ny=f[h[j]].y;
                if( sqrt((x[i] - nx) * (x[i] - nx) + (y[i] - ny) * (y[i] - ny)) <= z[i] + r){
                    cnt++;
                    break;
                }
            }
        }
        res=max(cnt,res);
        return;
    }
    for(long long i=1;i<=idx;i++){
        if(!vis[i]){
            vis[i]=1;
            h[step]=i;
            dfs(step+1);
            vis[i]=0;
        }
    }
    return;
}
int main(){
    cin>>n>>k>>r;
    for(long long i=1;i<=n;i++){
        cin>>x[i]>>y[i]>>z[i];
    }
    for(long long i=-5;i<=5;i++){
        for(long long j=-5;j<=5;j++){
            f[++idx]={i,j};
        }
    }
    dfs(1);
    cout<<res;
    return 0;
}
```
::::
::::success[时间复杂度]{open}
- 时间复杂度：$O(n^2 \times 2^n)$，其中 $n$ 是点的个数。
::::
:::::
::::::

---

# T715076 dfs-二维选和不选-3

## 题目描述

在一个 $5 \times 5$ 的棋盘内，放上 $n$ 颗棋子，其中 $5 \le n \le 25$；

这 $n$ 颗棋子可以放到棋盘内任意一个地方，但是不能重叠在一起。于是，便会有五颗棋子排成一行，或一列，或处在同一条对角线上。不同的放法可能会出现不同个数的五子的排列。

本题你要做的是，给你一个 $n$，你要找出不同放法出现的五子连线的数量（设为 $k$），如 $n=11$，有：

![](https://cdn.luogu.com.cn/upload/image_hosting/rcwazq5o.png)

只有这两种非负的 $k$ 值，（注意 $k$ 不重复），你要输出的便是 $k$ 值的和。

也就是 $1+2=3$。

## 输入格式

输入共一行一个数 $n$，含义如题意所示。保证 $1\le n\le 25$。

## 输出格式

输出所有可能的 $k$ 值的和。容易发现 $k\le 12$。

## 输入输出样例 #1

### 输入 #1

```
11
```

### 输出 #1

```
3
```

## 说明/提示

$30pts: 1 <= n <= 15$

$100pts: 1 <= n <= 25$

::::::info[题意简化]{open}
给定正整数 $n$，求不同放法出现的五子连线的数量（设为 $k$）。
::::::

::::::info[题解]{open}
:::::info[DFS（二维搜索）]{open}
- 
::::success[DFS（二维搜索）]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
bool vis[6][6];       
bool f[13];               
int ans=0;       
void check(){
    int k=0;
    for(int i=1;i<=5;i++){
        if(vis[i][1]&&vis[i][2]&&vis[i][3]&&vis[i][4]&&vis[i][5])k++;
        if(vis[1][i]&&vis[2][i]&&vis[3][i]&&vis[4][i]&&vis[5][i])k++;
    }
    if(vis[1][1]&&vis[2][2]&&vis[3][3]&&vis[4][4]&&vis[5][5])k++;
    if(vis[1][5]&&vis[2][4]&&vis[3][3]&&vis[4][2]&&vis[5][1])k++;
    f[k]=true;
    return;
}
void dfs(int i,int j,int cnt){
    if(cnt==n){
        check();
        return;
    }
    if(i==6)return;
    vis[i][j]=1;
    if(j==5)dfs(i+1,1,cnt+1);
    else dfs(i,j+1,cnt+1);
    vis[i][j]=0;
    if(j==5)dfs(i+1,1,cnt);
    else dfs(i,j+1,cnt);
}
int main(){
    cin>>n;
    dfs(1,1,0);
    for(int i=1;i<=12;i++){
        if(f[i])ans+=i;
    }
    cout<<ans;
    return 0;
}
```
::::
::::success[时间复杂度]{open}
- 时间复杂度：$O(
::::
:::::
::::::
---

# T711952 dfs-选和不选-4

::::::info[题意简化]{open}
给定正整数 $n$ 和 $v$ 以及 $n$ 个操作，操作是可选的。  
每个操作具有两个变量 $x$ 和 $y$，每个操作可以使两个初始值为 $0$ 的计数器 $a$ 和 $b$ 进行以下操作：  
  - 将 $a$ 加上 $x$。  
  - 将 $b$ 加上 $y$。  
问最终两个计数器总和超过 $v$ 的最小绝对差值。
::::::

::::::info[题解]{open}
:::::info[DFS（二维搜索）]{open}
- 每次使用深度优先搜索（DFS）选择或放弃一个操作，并计算两个计数器的总和。
- 每次将两个计数器的总和与 $v$ 进行比较，如果大于 $v$，则放弃该操作；否则，选择该操作。
- 对于每次递归调用，尝试选择或放弃一个操作，并计算两个计数器的总和。
- 最终输出两个计数器的总和的最小绝对差值。
::::warning[DFS剪枝]{open}
- 由于题目数据范围为 $n \leq 30$，因此暴力枚举所有可能的操作组合的时间复杂度为 $O(2^n)$，在实际运行中有可能超时。
- 所以我们可以使用最优性剪枝来优化搜索过程：
  - 如果 $minn$ 已经为 $0$，则说明已经找到了最小的绝对差值，直接输出 $0$ 即可。
::::
::::success[DFS（二维搜索）]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y,minn=1e9;
long long n,v;
long long a[100],b[100],vis[100];
void dfs(int cnt,long long sum,long long l,long long m){
    if(sum>v){
        minn=min(minn,abs(l-m));
    }
    if(minn==0){
        cout<<0;
        exit(0);
    }
    if(cnt==n+1) return;
    dfs(cnt+1,sum+a[cnt]+b[cnt],l+a[cnt],m+b[cnt]);
    dfs(cnt+1,sum,l,m);
    return;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>v;
    for(long long i=1;i<=n;i++){
        cin>>a[i]>>b[i];
    }
    dfs(1,0,0,0);
    if(minn==1e9) cout<<-1;
    else cout<<minn;
    return 0;
}

```
::::
::::success[时间复杂度]{open}
- 时间复杂度：$O(2^n)$，其中 $n$ 是操作个数。
::::
:::::
::::::
# 比赛情况
::cute-table{tuack}

|题目|分数|补题时间|
|:-----:|:--:|:---:|
|dfs-选和不选-1|70 |0.66h|
|dfs-选和不选-2|100|0.04h|
|dfs-选和不选-3|100|0.15h|
|dfs-选和不选-4|30 |0.49h|
|dfs-选和不选-5|0  |0.13h|
|dfs-选和不选-6|0  |0.13h|
---
# DFS（选和不选）
::::info[DFS算法]{open}
- 深度优先搜索（Depth-First Search，DFS）是一种用于遍历或搜索树或图的算法。它从根节点开始，沿着每个分支尽可能深入地搜索，直到达到叶子节点或没有未访问的邻居节点为止，然后回溯到上一个节点继续搜索其他分支。
- DFS 通常使用递归或栈来实现。它适用于解决许多问题，如路径搜索、连通性检测、拓扑排序等。
- 在这里的 DFS 将用于选和不选，即从多个数中选出一个（或多个）满足条件的数。
::::
::::info[选和不选]{open}
- 首先，我们来看一个例题：
:::info[P1036 \[NOIP 2002 普及组\] 选数]{open}
- 给定 $n$ 个正整数以及一个整数 $k (k < n)$，求选 $k$ 个正整数的和是质数的选法数。
:::
- 首先我们可以想出使用 $k$ 重循环来枚举每个数，但是这样写出来的代码太过冗余，所以我们可以使用递归代替多重循环。
- 实现：
:::success[全排列代码]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[25];
long long ans;
bool f(int x){ //简单的判断质数
    if(x==1||x!=2&&x%2==0)return 0;
    for(int i=3;i*i<=x;i++)if(x%i==0)return 0;
    return 1;
}
void dfs(int k,int s,int x){
    if(k==m){
        if(f(s))ans++;
        return;
    }
    for(int i=x;i<n;i++) dfs(k+1,s+a[i],i+1);
}
int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++)cin>>a[i];
    dfs(0,0,0);
    cout<<ans;
    return 0;
}

```
:::
::::

---

# 例题：

# T711945 dfs-选和不选-1

::::::info[题意简化]{open}
求`N`和`Y`的长度为 $k$ 全排列。
::::::

::::::info[题解]{open}
:::::info[DFS（选和不选）]{open}
 - 使用深度优先搜索（DFS）生成全排列，并输出。
::::success[DFS（选和不选）]{open}
```cpp
#include <bits/stdc++.h> 
using namespace std;
int n;
void dfs(int cur,string s){
    if(cur==n+1){
        cout<<s<<'\n'; 
        return;
    }
    dfs(cur +1,s+"N");
    dfs(cur+1,s+"Y");
}
int main(){
    cin>>n; 
    dfs(1,""); 
    return 0;
}
```
::::
::::success[时间复杂度]{open}
- 时间复杂度：$O(n!)$，其中 $n$ 是数字个数。
::::
:::::
::::::
---

# T711948 dfs-选和不选-2

::::::info[题意简化]{open}
- 给定正整数 $T,A,B$ 以及 $k$，你可以将计数器从 $0$ 开始，每次可以选择 $A$ 或 $B$，或将计数器的值除以 $2$（只能使用 $k$ 次除以），问最大的小于 $T$ 的整数是多少。
::::::

::::::info[题解]{open}
:::::info[DFS（选和不选）]{open}
 - 使用深度优先搜索（DFS）生成所有可能的选择，并计算每个选择的最大值，最终输出最大值。
 - 对于每个选择，计算最大值：从 $0$ 开始，每次可以选择 $A$ 或 $B$，或将计数器的值除以 $2$（只能使用 $k$ 次除以），直到达到 $T$ 或超过 $k$ 次除以。
 - 具体的，对于每个选择 $op$，计算最大值：
    - 如果选择 $A$，则计数器加上 $A$。
    - 如果选择 $B$，则计数器加上 $B$。
    - 如果选择除以 $2$，则计数器除以 $2$。
    - 直到达到 $T$ 或超过 $k$ 次除以。
::::success[DFS（选和不选）]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,a,b;
long long k;
long long maxn=-1e18;
void dfs(long long sum,long long op){
    if(sum+a<=t){
        maxn=max(maxn,sum+a);
        if(maxn==t) return;
        dfs(sum+a,op);
    }
    if(sum+b<=t){
        maxn=max(maxn,sum+b);
        if(maxn==t) return;
        dfs(sum+b,op);
    }
    if(op+1<=k){
        maxn=max(maxn,(long long)(sum/2));
        if(maxn==t) return;
        dfs((long long)(sum/2),op+1);
    }
    return;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>t>>a>>b;
    cin>>k;
    if(a==1||b==1||a==t||b==t){
        cout<<t;
        return 0;
    }
    dfs(0,0);
    cout<<maxn;
    return 0;
}
```
::::
::::success[时间复杂度]{open}
- 时间复杂度：$O(2^k)$，其中 $k$ 是除以 $2$ 的次数。
::::
:::::
::::::

---

# T711951 dfs-选和不选-3

::::::info[题意简化]{open}
给定一个正整数 $n$，求在 $1$ 到 $n$ 中有多少个使用十进制书写时，其每一位只包含 $7$ 或 $5$ 或 $3$ 的数。
::::::

::::::info[题解]{open}
:::::info[暴力枚举]{open}
- 枚举所有可能的数，并判断是否包含 $7$ 或 $5$ 或 $3$。
- 具体的，对于每个数 $x$，判断是否包含 $7$ 或 $5$ 或 $3$：
  - 首先使用拆分数位的方法，将 $x$ 拆分为 $d_1d_2d_3\cdots d_k$，其中 $d_i$ 为 $x$ 的第 $i$ 位。
  - 在拆分数位的过程中，如果 $d_i$ 为 $7$ 或 $5$ 或 $3$，则将对应的计数器加一。
  - 最后，如果计数器的值都为 $1$，则总计数器加一。
- 最终输出总计数器的值，即为符合条件的数的个数。
::::warning[暴力枚举]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
bool check(int x){
    int cnt1=0,cnt2=0,cnt3=0;
    while(x){
        if(x%10==7) cnt1++;
        else if(x%10==5) cnt2++;
        else if(x%10==3) cnt3++;
        x/=10;
    }
    return cnt1>=1&&cnt2>=1&&cnt3>=1;
}
int n,cnt;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=3;i<=n;i++){
        if(check(i)) cnt++;
    }
    cout<<cnt;
    return 0;
}

```
::::
::::warning[时间复杂度]{open}
- 时间复杂度：$O(n*log_10(n))$，其中 $n$ 是给定的正整数。
- 由于题目数据范围为 $n \leq 10^9$，该方法的运行时间过长。
::::
:::::
:::::info[DFS（选和不选）]{open}
- 使用深度优先搜索（DFS）生成所有包含 $7$ 或 $5$ 或 $3$ 的数，并判断每个数是否小于 $N$。
- 具体的，如果当前选择的数为 $x$ 并且 $x \leq N$，则将 $x$ 进行以下判断：
  - 判断 $x$ 是否包含 $7$ 或 $5$ 或 $3$。
  - 如果 $x$ 包含 $7$ 或 $5$ 或 $3$，则将计数器加一。
- 对于每次递归调用，尝试将 $x$ 乘以 $10$ 并加上 $7$ 或 $5$ 或 $3$，然后继续递归调用。
- 最终输出计数器的值，即为符合条件的数的个数。
::::success[DFS（选和不选）]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,cnt;
void dfs(long long x,long long op1,long long op2,long long op3){
    if(x<=n&&op1>=1&&op2>=1&&op3>=1) cnt++;
    if(x*10+7<=n) dfs(x*10+7,op1+1,op2,op3);
    if(x*10+5<=n) dfs(x*10+5,op1,op2+1,op3);
    if(x*10+3<=n) dfs(x*10+3,op1,op2,op3+1);
    return;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    dfs(0,0,0,0);
    cout<<cnt;
    return 0;
}
```
::::
::::success[时间复杂度]{open}
- 时间复杂度：$O(log_10(n))$，其中 $n$ 是给定的正整数。
- 由于题目数据范围为 $n \leq 10^9$，该方法可行。
::::
:::::
::::::
---

# T711952 dfs-选和不选-4

::::::info[题意简化]{open}
给定正整数 $n$ 和 $v$ 以及 $n$ 个操作，操作是可选的。  
每个操作具有两个变量 $x$ 和 $y$，每个操作可以使两个初始值为 $0$ 的计数器 $a$ 和 $b$ 进行以下操作：  
  - 将 $a$ 加上 $x$。  
  - 将 $b$ 加上 $y$。  
问最终两个计数器总和超过 $v$ 的最小绝对差值。
::::::

::::::info[题解]{open}
:::::info[DFS（选和不选）]{open}
- 每次使用深度优先搜索（DFS）选择或放弃一个操作，并计算两个计数器的总和。
- 每次将两个计数器的总和与 $v$ 进行比较，如果大于 $v$，则放弃该操作；否则，选择该操作。
- 对于每次递归调用，尝试选择或放弃一个操作，并计算两个计数器的总和。
- 最终输出两个计数器的总和的最小绝对差值。
::::warning[DFS剪枝]{open}
- 由于题目数据范围为 $n \leq 30$，因此暴力枚举所有可能的操作组合的时间复杂度为 $O(2^n)$，在实际运行中有可能超时。
- 所以我们可以使用最优性剪枝来优化搜索过程：
  - 如果 $minn$ 已经为 $0$，则说明已经找到了最小的绝对差值，直接输出 $0$ 即可。
::::
::::success[DFS（选和不选）]{open}
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y,minn=1e9;
long long n,v;
long long a[100],b[100],vis[100];
void dfs(int cnt,long long sum,long long l,long long m){
    if(sum>v){
        minn=min(minn,abs(l-m));
    }
    if(minn==0){
        cout<<0;
        exit(0);
    }
    if(cnt==n+1) return;
    dfs(cnt+1,sum+a[cnt]+b[cnt],l+a[cnt],m+b[cnt]);
    dfs(cnt+1,sum,l,m);
    return;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>v;
    for(long long i=1;i<=n;i++){
        cin>>a[i]>>b[i];
    }
    dfs(1,0,0,0);
    if(minn==1e9) cout<<-1;
    else cout<<minn;
    return 0;
}

```
::::
::::success[时间复杂度]{open}
- 时间复杂度：$O(2^n)$，其中 $n$ 是操作个数。
::::
:::::
::::::